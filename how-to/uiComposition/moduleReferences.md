# Module references

## Problem

The client wants to show a module inside another module to form a more complex view structure. This way, view parts could be in different view modules and let the classes be organized in a more manageable and maintainable way.

## Implementation
We can create a reference to the submodule we want to show by using the generic `Reference<T>` method in the parent module. Then this reference is used inside the markup in the parent module using the techniques discussed in [markup customisation](https://www.msharp.co.uk/#/how-to/stylingAndCSS/markupCustomisation) topic.


## Basic usage
Suppose that we have a `FormParent` form module that has a `ViewChild` module inside. To show this module, we should get a reference to this module and using `Ref` method on the reference to use it in the form markup in the same way we do for buttons or links.
```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild>();
        MarkupWrapper($@"<div>{view.Ref}[#MODULE#]</div>");
        //...
    }
}
```
Here in `MarkupWrapper` we have used the markup for the view followed by the markup for the form module itself i.e. `[#MODULE#]`.

## View component effect
Based on the condition that `ViewChild` be a view component or not in the above example, the following differences exist in the generated code:

| Specification   |     view componenet     | not view componenet |
| -------|:-------------:|:------------:|
| M# code for the `ViewChild`   | has `IsViewComponent` method | Is without `IsViewComponent` method     |
| ASP.Net concept used   | [view components](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-5.0) | [partial views](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-5.0)|
| Invoked as | `await Component.InvokeAsync<ViewChild>(Model.ViewChildInfo)` | `await Html.PartialAsync("ViewChild", Model.ViewChildInfo)`     |
| Default ViewModel property generated by using `Reference<T>`  | None      | `public vm.ViewChild ViewChildInfo { get; set; }` |
| Page lifecycle  | Don't take part in the parent page lifecycle | Have the same lifecycle as their parent page for requests and bindings     |

As you see, when `ViewChild` is a view component, then the ViewModel property is not generated automatically and must be specified in the `FormParent` using `ViewModelProperty<T>` method.

## Setting child data
When you have a module (e.g. `ViewChild`) referenced inside another module named `FormParent` and you want to configure some settings from the parent module, add an initialization code in the `FormParent` module to set its properties. 

When `ViewChild` is view component, the ViewModel property is not generated and should be defined. In this case, the code for configuring the `ViewChild` from the parent module will be as follows:

IsViewComponent
```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild>().ViewModelName("ViewInfo");
        ViewModelProperty<ViewChild>("ViewInfo");
        OnPreBinding("setting child view data")
                .Code(@"info.ViewInfo = new vm.ViewChild() { Prop1 = ""settingFromParent"" };");
        MarkupWrapper($@"
            <div>
                {view.Ref}
                [#MODULE#]
            </div>
        ");
        //...
    }
}
```
Here, the default ViewModel property name that is used for invoking the referenced module is changed using the `ViewModelName` method on the referenced module.

In the case `Viewchild` is not a view component, ViewModel property definition using the `ViewModelProperty<T>` method can be skipped.

Using the `OnPreBinding` method is the best place to put the initialization code for the referenced modules because it happens as soon as the ViewModel object is created, and before the Request (query string and form) data is written to the properties. When you have a complex view model structure such as modules that reference other modules, all `OnPreBound` methods execute before all `OnBound` methods.

## Multiple instances of the same view
You may want to show multiple instances of the same `ViewChild` module inside the `FormParent` module. In this case, you don't have to use multiple `Reference<T>`. Instead, use multiple ViewModel properties of the same type for each instance and use these properties in the markup for each instance.

```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view1 = Reference<ViewChild>().ViewModelName("ViewInfo1");
        var view2 = Reference<ViewChild>().ViewModelName("ViewInfo2");
        ViewModelProperty<ViewChild>("ViewInfo1");
        ViewModelProperty<ViewChild>("ViewInfo2");
        OnPreBinding("setting child viewes data")
                .Code(@"info.ViewInfo1 = new vm.ViewChild() { Prop1 = ""value1""};
                        info.ViewInfo2 = new vm.ViewChild() { Prop1 = ""value2""};" );
        MarkupWrapper($@"
            <div>
                {view1.Ref}
                {view2.Ref}
                [#MODULE#]
            </div>
        ");
        //...
    }
}
```

## Static referenced module hierarchy
You can have nested modules to form a hierarchy with multiple levels of module references similarly. For example for 2 levels of nesting, we can create the following structure:

```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild1>().ViewModelName("ViewInfo");
        ViewModelProperty<ViewChild1>("ViewInfo");
        OnPreBinding("setting childView1 data")
                .Code(@"info.ViewInfo = new vm.ViewChild1() { Prop1 = ""value1""}; ");
        MarkupWrapper($@"
            <div>
                [#MODULE#]
                {view.Ref}
            </div>
        ");
        //...
    }
}
```
The `ViewChild1` itself references `ViewChild2`.
```csharp
public class ViewChild1 : GenericModule
{
    public ViewChild1()
    {
        IsViewComponent();
        HeaderText("ViewChild1 @info.Prop1");
        ViewModelProperty<string>("Prop1");
        ViewModelProperty<ViewChild2>("ViewInfo");
        var view = Reference<ViewChild2>().ViewModelName("ViewInfo");
        MarkupWrapper($@"
            <div>
                [#MODULE#]
                {view.Ref}
            </div>
        ");
        OnPreBinding("setting childview2 data")
            .Code(@"info.ViewInfo = new vm.ViewChild2() { Prop2 = info.Prop1 + ""View2"" };");
    }
}
```
The `ViewChild2` is a simple class without any module reference.
```csharp
public class ViewChild2 : GenericModule
{
    public ViewChild2()
    {
        HeaderText("ViewChild2 @info.Prop2");
        ViewModelProperty<string>("Prop2");
    }
}
```
This kind of structure is useful for creating complex layout structure statically because the references are all known at the compile-time.

## Dynamic referenced module hierarchy
For dynamic hierarchical data that the number and level are unknown at the compile-time, we should tweak the markup and code a little more to make it work. 

For example, consider the `Node` class presented [here](https://www.msharp.co.uk/#/how-to/types/hierarchy?id=implementation) which has `children` and `Parent` association properties of the same type. We can create the following view module to show each node and its children:

```csharp
public class NodeView : ViewModule<Domain.Node>
{
    public NodeView()
    {
        IsViewComponent();
        ViewModelProperty<List<NodeView>>("ChildrenViews");
        Markup(@"
            <div>
                <h1>@info.Item.Name</h1>
                <div>
                @foreach (var view in Model.ChildrenViews)
                {
                    <div>@(await Component.InvokeAsync<NodeView>(view))</div>
                }
                </div>
            </div>
        ");
        OnPreBinding("setting child views")
                .Code(@"info.ChildrenViews = await info.Item.Children.GetList()
                            .Select(n => new vm.NodeView() { Item = n })
                            .ToList();");
    }
}
```
In this code, all the children are populated in the markup using direct invocation instead of using the reference to the `Refrerence<T>` because the module can't reference itself. For doing this, we have used `NodeView` as a view component.

With this view module, we can create the following view module to populate all the root nodes using the `NodeView`.

```csharp
public class RootNodesView : GenericModule
{
    public RootNodesView()
    {
        var nodeView = Reference<NodeView>();
        ViewModelProperty<List<NodeView>>("NodeViews");
        Markup($@"
            <div>
            @foreach (var view in Model.NodeViews)
            {{
                <div>{nodeView.GetRef("view")}</div>
            }}
            </div>
        ");
        OnPreBinding("setting NodeViews")
                .Code(@"info.NodeViews = await Node.GetRootNodes()
                            .Select(n => new vm.NodeView() { Item = n })
                            .ToList();");
    }
}
```
Here, `GetRootNodes` method is a static method created in the domain logic for populating all the root nodes from the database. The `Reference<T>` method is only used for resolving the type and namespace.

```csharp
partial class Node
{
    public static Task<IEnumerable<Node>> GetRootNodes() => 
        Database.Of<Node>().Where(n => n.ParentId == null).GetList();
}
```

## Module referenced inside a list
You can have module references to be used inside lists. They can be created for each list item by using `UsedPerItem` method on the object returned by the `Reference<T>`.

Two common scenarios for using this pattern are nested lists and custom form per list item.

### Nested list
Consider the example in [this page](https://www.msharp.co.uk/#/../Tutorials/10/README).  We may want to change the `AgenciesList` so that a new column be added to show the `BookingsList` for that agency nested inside the list for each row. This column can be added using a custom column.

```csharp
public class AgenciesList : ListModule<Domain.Agency>
{
    public AgenciesList()
    {
        //...
        var view = Reference<BookingsList>().UsedPerItem();
        CustomColumn()
            .LabelText("Bookings")
            .DisplayExpression(view.Ref);
        OnPostBound("setting agencies for each row")
            .Code("listItem.BookingsListInfo.Agency = item;")
            .PerListItem();
    }
}
```
Here `UsedPerItem` and `PerListItem` is used because we have different references for each row. The template for `BookingsList` is placed inside the column by using `DisplayExpression(view.Ref)`. After doing this, the code for `BookingsList` should be changed a little because the agency is no longer coming from the request parameters.

```csharp
public class BookingsList : ListModule<Domain.Booking>
{
    public BookingsList()
    {
        HeaderText("@info.Agency.Name 's bookings");
        //...
        ViewModelProperty("Agency", "Agency").RetainInPost();
        //...
    }
}
```
Here, the `RetainInPost` method is used to retain the state of the ViewModel property in the post requests.