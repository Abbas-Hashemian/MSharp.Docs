# Module references

## Problem

The client wants show a module inside another module.

## Implementation
We can create a reference to the submodule we want to show by using the generic `Reference<T>` method in the parent module. Then this reference is used inside the markup in the parent module using the techniques discussed in [markup customisation](https://www.msharp.co.uk/#/how-to/stylingAndCSS/markupCustomisation) topic.


## Basic usage
Suppose that we have a `FormParent` form module that has a `ViewChild` module inside. To show this module, we should get a reference to this module and using `Ref` method on the reference to use it in the form markup in the same way we do for buttons or links.
```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild>();
        MarkupWrapper($@"<div>{view.Ref}[#MODULE#]</div>");
        //...
    }
}
```
Here in `MarkupWrapper` we have used the markup for the view followed by the markup for the form module itself i.e. `[#MODULE#]`.

## View component effect
Based on the condition that `ViewChild` be a view component or not in the above example, the following differences exist in the generated code:

| Specification   |     view componenet     | not view componenet |
| -------|:-------------:|:------------:|
| M# code for the `ViewChild`   | has `IsViewComponent` method | Is without `IsViewComponent` method     |
| ASP.Net concept used   | [view components](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-5.0) | [partial views](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-5.0)|
| Invoked as | `await Component.InvokeAsync   <ViewChild>      (Model.ViewChildInfo)` | `await Html.PartialAsync("ViewChild", Model.ViewChildInfo)`     |
| ViewModel property generated by using `Reference<T>`  | `public vm.ViewChild ViewChildInfo { get; set; }` | None      |
| Page lifecycle  | Don't take part in the parent page lifecycle | Have the same lifecycle as their parent page for requests and bindings     |

As you see, when `ViewChild` is not a view component, then the ViewModel property is not generated automatically and must be specified in the `FormParent`.

## Setting child data
When you have a module (e.g. `ViewChild`) referenced inside another module named `FormParent` and you want to configure some settings from the parent module, add an initialization code in the `FormParent` module to set its properties. 

Using the `OnPreBinding` method is the best place to put the initialization code for the referenced modules because it happens as soon as the ViewModel object is created, and before the Request (query string and form) data is written to the properties. When you have a complex view model structure such as modules that reference other modules, all `OnPreBound` methods execute before all `OnBound` methods.

```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild>();
        ViewModelProperty<ViewChild>("ViewInfo");
        OnPreBinding("setting child view data")
                .Code(@"info.ViewInfo = new vm.ViewChild() { Prop1 = ""settingFromParent"" };");
        MarkupWrapper($@"
            <div>
                {view..ViewModelName("ViewInfo").Ref}
                [#MODULE#]
            </div>
        ");
        //...
    }
}
```
You can also set the `DataSource` of the `ViewChild` to `info.Item`. This will enforce a `[ReadOnly]` attribute on the child item and so skip the automatic binding.

## Multiple instances of the same view
You may want to show multiple instances of the same `ViewChild` module inside the `FormParent` module. In this case, you don't have to use multiple `Reference<T>`. Instead, use multiple ViewModel properties of the same type for each instance and use these properties in the markup for each instance.

```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild>();
        ViewModelProperty<ViewChild>("ViewInfo1");
        ViewModelProperty<ViewChild>("ViewInfo2");
        OnPreBinding("setting child viewes data")
                .Code(@"info.ViewInfo1 = new vm.ViewChild() { Prop1 = ""value1""};
                        info.ViewInfo2 = new vm.ViewChild() { Prop1 = ""value2""};" );
        MarkupWrapper($@"
            <div>
                {view..ViewModelName("ViewInfo1").Ref}
                {view..ViewModelName("ViewInfo2").Ref}
                [#MODULE#]
            </div>
        ");
        //...
    }
}
```

## Static Reference hierarchy
You can have nested modules to form a hierarchy with multiple levels of module references similarly. For example for 2 levels of nesting we can create the following structure:

```csharp
public class FormParent : FormModule<Domain.AnEntity>
{
    public FormParent()
    {
        var view = Reference<ViewChild1>();
        ViewModelProperty<ViewChild1>("ViewInfo");
        OnPreBinding("setting childView1 data")
                .Code(@"info.ViewInfo = new vm.ViewChild1() { Prop1 = ""value1""}; ");
        MarkupWrapper($@"
            <div>
                [#MODULE#]
                {view.ViewModelName("ViewInfo").Ref}
            </div>
        ");
        //...
    }
}
```
The `ViewChild1` itself references `ViewChild2`.
```csharp
public class ViewChild1 : GenericModule
{
    public ViewChild1()
    {
        IsViewComponent();
        HeaderText("ViewChild1 @info.Prop1");
        ViewModelProperty<string>("Prop1");
        ViewModelProperty<ViewChild2>("ViewInfo");
        var view = Reference<ViewChild2>();
        MarkupWrapper($@"
            <div>
                [#MODULE#]
                {view.ViewModelName("ViewInfo").Ref}
            </div>
        ");
        OnPreBinding("setting childview2 data")
            .Code(@"info.ViewInfo = new vm.ViewChild2() { Prop2 = info.Prop1 + ""View2"" };");
    }
}
```
The `ViewChild2` is a simple class without the module reference.
```csharp
public class ViewChild2 : GenericModule
{
    public ViewChild2()
    {
        HeaderText("ViewChild2 @info.Prop2");
        ViewModelProperty<string>("Prop2");
    }
}
```
This kind of structure is useful for creating complex layout structure statically because the references are all known at compile time.